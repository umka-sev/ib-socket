Bottom: 877b66c38720851d2ae0ad01da7d2dbd23456139
Top:    0e08d44265caaff6f8b8352ef618f9e52cd5d30e
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-02-01 23:15:13 +0300

Refresh of ctl-verbs.patch

---

diff --git a/ib-sock-ctl.c b/ib-sock-ctl.c
index 6fa71de..ed4582e 100644
--- a/ib-sock-ctl.c
+++ b/ib-sock-ctl.c
@@ -47,6 +47,12 @@ int ib_sock_ctl_post(struct IB_SOCK *sock, struct ib_sock_ctl *msg)
 	 */
 	struct ib_recv_wr wr;
 	struct ib_recv_wr *bad_wr;
+	struct ib_device *device = sock->is_id->device;
+
+	/* trasnfer ownership to the device */
+	ib_dma_sync_single_for_device(device, 
+				   msg->iscm_sge.addr, msg->iscm_sge.length,
+				   DMA_FROM_DEVICE);
 
 	msg->iscm_flags |= CTL_MSG_RX;
 
@@ -105,6 +111,7 @@ int ib_sock_ctl_init(struct IB_SOCK *sock)
 	init_waitqueue_head(&sock->is_ctl_waitq);
 	INIT_LIST_HEAD(&sock->is_ctl_active_list);
 	INIT_LIST_HEAD(&sock->is_ctl_idle_list);
+	INIT_LIST_HEAD(&sock->is_ctl_rd_list);
 
 	/* preallocate until limit.
 	 * we can allocate it by request, but simplify a code
diff --git a/ib-sock-int.h b/ib-sock-int.h
index 25bafe2..4eda29d 100644
--- a/ib-sock-int.h
+++ b/ib-sock-int.h
@@ -67,10 +67,11 @@ struct IB_SOCK {
 	struct ib_qp		*is_qp;
 
 	/* control messages */
-	/* IDLE <> active protection  */
+	/* IDLE <> active <> rd protection  */
 	spinlock_t		is_ctl_lock;
 	struct list_head	is_ctl_idle_list;
 	struct list_head	is_ctl_active_list;
+	struct list_head	is_ctl_rd_list;
 	wait_queue_head_t	is_ctl_waitq;
 	/******* transfer related parts end ************/
 
@@ -96,13 +97,14 @@ void sock_event_set(struct IB_SOCK *sock, unsigned int event)
 #define IB_HELLO_MAGIC 0x9012
 
 struct ib_hello {
-	__u32	magic;
+	uint32_t	magic;
 } WIRE_ATTR;
 
 #define IB_CTL_MSG_MAGIC	0x87154
 
 struct ib_sock_wire_msg {
 	uint32_t	sww_magic;
+	uint32_t	sww_size;
 } WIRE_ATTR;
 
 /**************************** messages on wire ********************/
@@ -130,7 +132,8 @@ struct ib_sock_ctl {
 int ib_sock_ctl_init(struct IB_SOCK *sock);
 void ib_sock_ctl_fini(struct IB_SOCK *sock);
 /* take control message to send an outgoning buffer */
-struct ib_sock_ctl *ib_sock_ctl_idle_take(struct IB_SOCK *sock);
+struct ib_sock_ctl *ib_sock_ctl_take(struct IB_SOCK *sock);
+void ib_sock_ctl_put(struct IB_SOCK *sock, struct ib_sock_ctl *msg);
 int ib_sock_ctl_post(struct IB_SOCK *sock, struct ib_sock_ctl *msg);
 
 
diff --git a/ib-sock.c b/ib-sock.c
index c87ac81..64ce7c7 100644
--- a/ib-sock.c
+++ b/ib-sock.c
@@ -30,19 +30,24 @@ static void ib_sock_handle_rx(struct IB_SOCK *sock, struct ib_wc *wc)
 	}
 
 
-	if (msg->iscm_msg.sww_magic == IB_CTL_MSG_MAGIC)
-		printk("recv maic ok!\n");
-	else
+	if (msg->iscm_msg.sww_magic != IB_CTL_MSG_MAGIC) {
 		printk("recv magic bad %x\n", msg->iscm_msg.sww_magic);
+		goto repost;
+	}
 
+	/* do processing there */
+	printk("recv maic ok!\n");
+	spin_lock(&sock->is_ctl_lock);
+	list_move(&msg->iscm_link, &sock->is_ctl_rd_list);
+	spin_lock(&sock->is_ctl_lock);
+
+	/* ready for userland */
+	sock_event_set(sock, POLLIN);
 repost:
-	/* trasnfer ownership to the device */
-	ib_dma_sync_single_for_device(device, 
-				   msg->iscm_sge.addr, msg->iscm_sge.length,
-				   DMA_FROM_DEVICE);
 	/* repost to processing */
 	ret  = ib_sock_ctl_post(sock, msg);
-	if (ret != 0)
+	if (ret != 0) 
+		/* probably we need a chanse to report it later ? */
 		printk("Error with summit to rx queue\n");
 }
 
@@ -576,3 +581,67 @@ struct IB_SOCK *ib_socket_accept(struct IB_SOCK *parent)
 	printk("Accept returned %p\n", sock);
 	return sock;
 }
+/*****************************************************************************************/
+/* return a size of transfer */
+size_t ib_socket_read_size(struct IB_SOCK *sock)
+{
+	struct ib_sock_ctl *msg;
+	int ret = -EAGAIN;
+
+	/* as we have a single parallel transfer - 
+	 * just enough to check a first element in list */
+	spin_lock(&sock->is_ctl_lock);
+	msg = list_first_entry_or_null(&sock->is_ctl_rd_list,
+				       struct ib_sock_ctl, iscm_link);
+	if (msg != NULL)
+		ret = msg->iscm_msg.sww_size;
+	spin_unlock(&sock->is_ctl_lock);
+
+	return ret;
+}
+
+/* process contol msg and repost */
+int ib_socket_read(struct IB_SOCK *sock, void *buf, size_t size)
+{
+	struct ib_sock_ctl *msg;
+
+	/* as we have a single parallel transfer - 
+	 * just enough to check a first element in list */
+	spin_lock(&sock->is_ctl_lock);
+	msg = list_first_entry_or_null(&sock->is_ctl_rd_list,
+				       struct ib_sock_ctl, iscm_link);
+	if (msg != NULL)
+		list_del(&msg->iscm_link);
+	spin_unlock(&sock->is_ctl_lock);
+	if (msg == NULL)
+		return -EAGAIN;
+
+	return ib_sock_ctl_post(sock, msg);
+}
+
+/* send some amount data over wire */
+int ib_socket_write(struct IB_SOCK *sock, void *buf, size_t size)
+{
+	/* stub. send an CTL msg only */
+	struct ib_sock_ctl *msg;
+	struct ib_send_wr wr = {
+		.opcode = IB_WR_SEND,
+	};
+	struct ib_send_wr *bad;
+	int ret = -EINVAL;
+
+	msg = ib_sock_ctl_take(sock);
+
+	wr.next = NULL;
+	wr.wr_id = (uintptr_t)msg;
+	wr.sg_list = &msg->iscm_sge;
+	wr.num_sge = 1;
+
+	ret = ib_post_send(sock->is_qp, &wr, &bad);
+	/* if OK - will returned in idle list in the callback */
+	if (ret != 0)
+		ib_sock_ctl_put(sock, msg);
+
+	return ret;
+}
+
diff --git a/ib-sock.h b/ib-sock.h
index c74c3df..f6f6c51 100644
--- a/ib-sock.h
+++ b/ib-sock.h
@@ -28,7 +28,18 @@ unsigned long ib_socket_poll(struct IB_SOCK *sock);
 int ib_socket_bind(struct IB_SOCK *sock, uint32_t addr, unsigned port);
 struct IB_SOCK *ib_socket_accept(struct IB_SOCK *parent);
 
+/* return a size of transfer */
+size_t ib_socket_read_size(struct IB_SOCK *sock);
+/* submit to read.
+ * read protocol
+ * first POLLIN event have result to call ib_socket_read_try to get a buffer size
+ *  and call of ib_socket_read will send request to read and attach a buffers
+ * but return a EAGAIN to wait a transfer done
+ * next POLLIN event will inducate a transfer done  */
+int ib_socket_read(struct IB_SOCK *sock, void *buf, size_t size);
+
+
 /* send some amount data over wire */
-size_t ib_socket_write(struct IB_SOCK *sock, void *buf, size_t size);
+int ib_socket_write(struct IB_SOCK *sock, void *buf, size_t size);
 
 #endif
\ No newline at end of file
