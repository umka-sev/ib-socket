Bottom: 7ad6247784d9ec21c15709b193b73283274224a9
Top:    596c118522e14a7e8fa8e2d636285ac50ddb2319
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-01-15 21:42:11 +0300

Refresh of srv.patch

---

diff --git a/ib-sock.c b/ib-sock.c
index 66acf02..6eab374 100644
--- a/ib-sock.c
+++ b/ib-sock.c
@@ -1,6 +1,9 @@
 #include "ib-sock.h"
 #include "ib-sock-int.h"
 
+struct IB_SOCK *__ib_socket_create(struct rdma_cm_id *cm_id);
+
+
 static int
 cm_client_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 {
@@ -68,6 +71,56 @@ cm_client_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 	return ret;
 }
 
+static int
+cm_server_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
+{
+	int ret = 0;
+
+	switch (event->event) {
+	case RDMA_CM_EVENT_CONNECT_REQUEST: {
+		/* incomming request - lets allocate a resources for a new connect */
+		const struct ib_hello *hello = event->param.conn.private_data;
+		struct ib_hello hello_ack;
+		struct rdma_conn_param	conn_param;
+		struct IB_SOCK *sock;
+
+		if (hello->magic != IB_HELLO_MAGIC) {
+			printk("Incomming error: len %u magic %x\n",
+				event->param.conn.private_data_len,
+				hello->magic);
+			ret = -EPROTO;
+			break;
+		}
+
+		sock = __ib_socket_create(cmid);
+		if (ret != 0) {
+			printk("error accept \n");
+			ret = -ENOMEM;
+			break;
+		}
+
+		memset(&hello_ack, 0, sizeof hello_ack);
+
+		memset(&conn_param, 0, sizeof conn_param);
+		conn_param.private_data_len = sizeof hello_ack;
+		conn_param.private_data = &hello_ack;
+		conn_param.responder_resources = 0 /* no atomic */;
+		conn_param.initiator_depth = 0;
+		conn_param.retry_count = 10;
+
+		ret = rdma_accept(sock->is_id, &conn_param);
+		break;
+	}
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	printk("server CM event ret %d\n", ret);
+
+	return ret;
+}
+
 
 static int cm_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 {
@@ -88,6 +141,12 @@ static int cm_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 		break;
 	/* server related events */
 	case RDMA_CM_EVENT_CONNECT_REQUEST:
+		ret = cm_server_handler(cmid, event);
+		/* if we have any errors (including protocol violation 
+		 * during connect handshake, we need a destroy new allocated
+		 * cm_id  */
+		if (ret < 0)
+			return ret;
 		break;
 	/* some common errors */
 	case RDMA_CM_EVENT_ADDR_ERROR:
@@ -121,7 +180,7 @@ static int cm_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 	return 0;
 }
 
-struct IB_SOCK *ib_socket_create()
+struct IB_SOCK *__ib_socket_create(struct rdma_cm_id *cm_id)
 {
 	struct IB_SOCK *sock;
 
@@ -129,13 +188,8 @@ struct IB_SOCK *ib_socket_create()
 	if (sock == NULL)
 		return NULL;
 
-	sock->is_id = rdma_create_id(cm_handler, sock,
-					     RDMA_PS_TCP, IB_QPT_RC);
-	if (IS_ERR(sock->is_id)) {
-		printk("error create cm_id %ld\n", PTR_ERR(sock->is_id));
-		sock->is_id = NULL;
-		goto out_free;
-	}
+	sock->is_id = cm_id;
+	cm_id->context = sock;
 
 	sock->is_flags = 0;
 
@@ -146,9 +200,24 @@ struct IB_SOCK *ib_socket_create()
 	
 	printk("IB socket create %p\n", sock);
 	return sock;
-out_free:
-	ib_socket_destroy(sock);
-	return NULL;
+}
+
+struct IB_SOCK *ib_socket_create()
+{
+	struct rdma_cm_id *cm_id;
+	struct IB_SOCK *ret;
+	
+	cm_id = rdma_create_id(cm_handler, NULL, RDMA_PS_TCP, IB_QPT_RC);
+	if (IS_ERR(cm_id)) {
+		printk("error create cm_id %ld\n", PTR_ERR(cm_id));
+		return NULL;
+	}
+
+	ret = __ib_socket_create(cm_id);
+	if (ret == NULL)
+		rdma_destroy_id(cm_id);
+
+	return ret;
 }
 
 void ib_socket_destroy(struct IB_SOCK *sock)
