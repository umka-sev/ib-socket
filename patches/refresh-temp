Bottom: 552d3ddcd525cd061062030a789eccb57e69168d
Top:    599aa3d7b298b76d67c73ec1d45cbd6fbb325324
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-01-18 07:48:38 +0300

Refresh of srv.patch

---

diff --git a/ib-sock.c b/ib-sock.c
index 3deb291..c79a279 100644
--- a/ib-sock.c
+++ b/ib-sock.c
@@ -113,7 +113,7 @@ cm_server_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 		ret = rdma_accept(sock->is_id, &conn_param);
 		if (ret < 0) {
 			/* will destroy after exit from event cb */
-			sock->is_id == NULL;
+			sock->is_id = NULL;
 			ib_socket_destroy(sock);
 			return ret;
 		}
diff --git a/srv.c b/srv.c
index 76fb030..feb9c9b 100644
--- a/srv.c
+++ b/srv.c
@@ -5,7 +5,7 @@
 static int __init
 srv_init(void)
 {
-	struct IB_SOCK *sock;
+	struct IB_SOCK *sock, *sock_child = NULL;
 	unsigned long event;
 	int ret;
 
@@ -17,9 +17,23 @@ srv_init(void)
 	if (ret < 0)
 		goto out;
 
+	/* wait incomming connect */
+	while ((event & POLLIN) == 0) {
 	event = ib_socket_poll(sock);
-	/* wait a POLLIN to say new connection ready to */
-
+		/* wait a POLLIN to say new connection ready to */
+		if ((event & POLLERR) != 0)
+			goto out;
+	}
+	/* have incomming event, so socket is ready */
+	sock_child = ib_socket_accept(sock);
+	BUG_ON(sock_child == NULL);
+
+	while ( 1 ) {
+		event = ib_socket_poll(sock_child);
+		if (event & POLLERR)
+			break;
+	}
+	ib_socket_destroy(sock_child);
 out:
 	ib_socket_destroy(sock);
 	return 0;
