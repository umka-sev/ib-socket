Bottom: 0e08d44265caaff6f8b8352ef618f9e52cd5d30e
Top:    ae021e49d42717db8ff626a6c73e32165a632afb
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-02-02 14:29:36 +0300

Refresh of ctl-verbs.patch

---

diff --git a/cli.c b/cli.c
index f0bcd39..2732030 100644
--- a/cli.c
+++ b/cli.c
@@ -38,6 +38,14 @@ cli_init(void)
 	}
 	event = ib_socket_poll(sock);
 	printk("Event hit %lx\n", event);
+	if (event & POLLOUT) {
+		err = ib_socket_write(sock, srv_addr, strlen(srv_addr));
+		printk("status send %d\n", err);
+	}
+	/* next event when transfer is done */
+	printk("Event hit %lx\n", event);
+	event = ib_socket_poll(sock);
+
 
 	ib_socket_disconnect(sock);
 exit:
diff --git a/srv.c b/srv.c
index 6f350e9..105d18a 100644
--- a/srv.c
+++ b/srv.c
@@ -7,6 +7,8 @@ srv_init(void)
 {
 	struct IB_SOCK *sock, *sock_child = NULL;
 	unsigned long event = 0;
+	bool read_st;
+	void *data;
 	int ret;
 
 	sock = ib_socket_create();
@@ -28,13 +30,28 @@ srv_init(void)
 	/* have incomming event, so socket is ready */
 	sock_child = ib_socket_accept(sock);
 	BUG_ON(sock_child == NULL);
-#if 0
+
 	while ( 1 ) {
 		event = ib_socket_poll(sock_child);
 		if (event & POLLERR)
 			break;
+		if (!read_st && (event & POLLIN)) {
+			size_t d_size;
+
+			d_size = ib_socket_read_size(sock);
+			data = kmalloc(d_size, GFP_KERNEL);
+			if (data == NULL)
+				break;
+			read_st = true;
+		}
+		if (read_st && (event & POLLIN)) {
+			/* read done */
+			printf("%s\n", data);
+			kfree(data);
+			read_st = false;
+		}
 	}
-#endif
+
 	ib_socket_destroy(sock_child);
 out:
 	ib_socket_destroy(sock);
