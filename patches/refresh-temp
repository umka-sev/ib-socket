Bottom: 4fdac40b93cac58dc6e13455190cf5badb361b2b
Top:    552d3ddcd525cd061062030a789eccb57e69168d
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-01-17 19:22:53 +0300

Refresh of srv.patch

---

diff --git a/ib-sock-int.h b/ib-sock-int.h
index c978399..d2a1904 100644
--- a/ib-sock-int.h
+++ b/ib-sock-int.h
@@ -24,6 +24,7 @@ struct IB_SOCK {
 	unsigned long		is_flags;
 
 	/* pre-accepted sockets */
+	spinlock_t		is_child_lock;
 	struct list_head	is_child;
 
 	/* event mask */
diff --git a/ib-sock.c b/ib-sock.c
index ae6a5e7..3deb291 100644
--- a/ib-sock.c
+++ b/ib-sock.c
@@ -70,7 +70,7 @@ cm_client_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 	printk("client CM event ret %d\n", ret);
 	return ret;
 }
-
+/**************************************************************************************/
 static int
 cm_server_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 {
@@ -82,6 +82,7 @@ cm_server_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 		const struct ib_hello *hello = event->param.conn.private_data;
 		struct ib_hello hello_ack;
 		struct rdma_conn_param	conn_param;
+		struct IB_SOCK *parent = cmid->context;
 		struct IB_SOCK *sock;
 
 		if (hello->magic != IB_HELLO_MAGIC) {
@@ -93,7 +94,7 @@ cm_server_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 		}
 
 		sock = __ib_socket_create(cmid);
-		if (ret != 0) {
+		if (sock != NULL) {
 			printk("error accept \n");
 			ret = -ENOMEM;
 			break;
@@ -110,6 +111,17 @@ cm_server_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 		conn_param.retry_count = 10;
 
 		ret = rdma_accept(sock->is_id, &conn_param);
+		if (ret < 0) {
+			/* will destroy after exit from event cb */
+			sock->is_id == NULL;
+			ib_socket_destroy(sock);
+			return ret;
+		}
+
+		spin_lock(&parent->is_child_lock);
+		list_add(&sock->is_child, &parent->is_child);
+		spin_unlock(&parent->is_child_lock);
+
 		break;
 	}
 	default:
@@ -197,6 +209,7 @@ struct IB_SOCK *__ib_socket_create(struct rdma_cm_id *cm_id)
 	sock->is_flags = 0;
 
 	INIT_LIST_HEAD(&sock->is_child);
+	spin_lock_init(&sock->is_child_lock);
 
 	sock->is_events = 0;
 	init_waitqueue_head(&sock->is_events_wait);
@@ -333,9 +346,12 @@ struct IB_SOCK *ib_socket_accept(struct IB_SOCK *parent)
 {
 	struct IB_SOCK *sock;
 
+	spin_lock(&parent->is_child_lock);
 	sock = list_first_entry_or_null(&parent->is_child, struct IB_SOCK, is_child);
 	if (sock) {
+		/* none can touch new socket until it accepted */
 		list_del_init(&sock->is_child);
 	}
+	spin_unlock(&parent->is_child_lock);
 	return sock;
 }
