Bottom: e8cc222994a5c259ce93dc5f887e9f3f5a4dee22
Top:    eb9a53c3632e380a0c544fae34cecf36cb4aa8eb
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-01-20 09:09:23 +0300

Refresh of wr-base.patch

---

diff --git a/ib-sock-ctl.c b/ib-sock-ctl.c
index 9441486..324b505 100644
--- a/ib-sock-ctl.c
+++ b/ib-sock-ctl.c
@@ -37,6 +37,7 @@ void ib_sock_ctl_put(struct IB_SOCK *sock, struct ib_sock_ctl *msg)
 	list_add(&msg->iscm_link, &sock->is_ctl_idle_list);
 	wake_up(&sock->is_ctl_waitq);
 }
+
 struct kmem_cache *ib_sock_ctl;
 
 int ib_sock_ctl_init(struct IB_SOCK *sock)
@@ -65,13 +66,24 @@ int ib_sock_ctl_init(struct IB_SOCK *sock)
 		if (msg == NULL)
 			continue;
 		count ++;
-		/* pre init */
-
+		/* pre init and put to idle */
+		ib_sock_ctl_put(msg);
 	}
 	return 0;
 }
 
 void ib_sock_ctl_fini(struct IB_SOCK *sock)
 {
-	
+	struct ib_sock_ctl *pos, *next;
+
+	/* i don't know how an abort active controls for now */
+	BUG_ON(!list_empty(&sock->is_ctl_active_list));
+
+	list_for_each_entry_safe(pos, next, &sock->is_ctl_active_list,
+				 iscm_link) {
+		list_del(&pos->iscm_link);
+
+		kmem_cache_free(ib_sock_ctl, pos);
+	}
+
 }
\ No newline at end of file
diff --git a/ib-sock-int.h b/ib-sock-int.h
index 71fc6cf..e2015ff 100644
--- a/ib-sock-int.h
+++ b/ib-sock-int.h
@@ -76,6 +76,30 @@ void sock_event_set(struct IB_SOCK *sock, unsigned int event)
 	wake_up(&sock->is_events_wait);
 }
 
+/* IB card operation. it's chain of WR's with own
+ * sge */
+/* differences between read and write operation 
+ * just an IB wr opcode, and one WR at begin to transfer 
+ * a transfer descriptor.
+ * it message may replaced with MAD packet, but i don't find how
+ * to do it.
+ */
+struct ib_sock_wr {
+	struct list_head	isw_link;
+
+	/* possition in WR array to use */
+	unsigned		isw_wr_pos;
+	/* preallocated send work items.. in ring.
+	 * did we need a static allocation ?
+	 */
+	struct ib_send_wr	*isw_wrq;
+
+	/* ...and their memory */
+	unsigned		isw_sge_pos;
+	struct ib_sge		*isw_sge;
+};
+
+
 /**************************** messages on wire ********************/
 #define WIRE_ATTR	__attribute__((packed))
 
@@ -101,7 +125,15 @@ struct ib_sock_ctl {
 	 * must be first WR in sending chain */
 	struct ib_sock_wire_msg	iscm_msg;
 };
-/************* ib sock control protocol ***************************/
+/************* ib sock control protocol end ************************/
+
+
+/* wr.c */
+struct ib_sock_wr *wr_idle_get(struct IB_SOCK *sock);
+void wr_put(struct IB_SOCK *sock, struct ib_sock_wr *wr);
+int wr_init(struct IB_SOCK *sock);
+void wr_fini(struct IB_SOCK *sock);
+
 /* ctl-msg.c */
 /* init queue and post sort of rx buffer to wait incomming data */
 int ib_sock_ctl_msg_init(struct IB_SOCK *sock);
diff --git a/ib-sock-wr.c b/ib-sock-wr.c
new file mode 100644
index 0000000..115588e
--- /dev/null
+++ b/ib-sock-wr.c
@@ -0,0 +1,125 @@
+#include "ib-sock-int.h"
+
+/* TX is main IB object. It hold an IB card operations (WR) and 
+ * memory attached to it.
+ * for operations read/write from network WR have a single differences
+ * just an WR opcode. Different memory managment models may have different
+ * list of WR opcodes in signle chain.
+ */
+
+static bool __take_free_wr(struct IB_SOCK *sock, struct ib_sock_wr **wr)
+{
+	struct ib_sock_wr *_wr;
+
+	/* XXX protect */
+	_wr = list_first_entry_or_null(&sock->is_wr_idle_list,
+					struct ib_sock_wr, isw_link);
+	if (_wr != NULL) {
+		list_del(&_wr->isw_link);
+		list_add(&_wr->isw_link, &sock->is_wr_active_list);
+
+		_wr->isw_wr_pos = 0;
+		_wr->isw_sge_pos = 0;
+
+		*wr = _wr;
+	}
+
+	return _wr != NULL;
+}
+
+struct ib_sock_wr *tx_idle_get(struct IB_SOCK *sock)
+{
+	struct ib_sock_wr *wr;
+
+       /* take an IDLE TX, if none available - try to allocated one
+        * with new WR index  */
+       wait_event(sock->is_wr_waitq, __take_free_wr(sock, &wr));
+       if (wr == NULL)
+               return NULL;
+
+	return wr;
+}
+
+/* return to idle */
+void wr_put(struct IB_SOCK *sock, struct ib_sock_wr *wr)
+{
+	list_add(&wr->isw_link, &sock->is_wr_idle_list);
+	wake_up(&sock->is_wr_waitq);
+}
+
+static void wr_destroy_one(struct ib_sock_wr *wr)
+{
+	if (wr->isw_wrq)
+		kfree(wr->isw_wrq);
+
+	if (wr->isw_sge)
+		kfree(wr->isw_sge);
+}
+
+static int wr_init_one(struct IB_SOCK *sock, struct ib_sock_wr *wr)
+{
+	size_t sz;
+
+	sz = sizeof(*wr->isw_wrq) * sock->is_mem.ism_wr_count;
+	wr->isw_wrq = kmalloc(sz, GFP_KERNEL);
+	if (wr->isw_wrq == NULL)
+		goto out_err;
+
+	sz = sizeof(*wr->isw_sge) * sock->is_mem.ism_sge_count;
+	wr->isw_sge = kmalloc(sz, GFP_KERNEL);
+	if (wr->isw_sge == NULL)
+		goto out_err;
+
+	wr->isw_wr_pos = 0;
+	wr->isw_sge_pos = 0;
+
+	return 0;
+out_err:
+	wr_destroy_one(wr);
+	return -ENOMEM;
+}
+
+/*
+ * allocate an number TX based on number paralel operations.
+ * as TX uses for both (transmit and recerve) operations,
+ * we need twice more than parallel transfers.
+ * each transfer hold a own WR list + own memory
+ */
+int wr_init(struct IB_SOCK *sock)
+{
+	struct ib_sock_wr *wr;
+	size_t num_wr = sock->is_parallel * 2;
+	int i;
+
+	INIT_LIST_HEAD(&sock->is_wr_idle_list);
+	INIT_LIST_HEAD(&sock->is_wr_active_list);
+
+	/* may on demand */
+	for (i = 0; i < num_wr; i++) {
+		wr = kmalloc(sizeof(*wr), GFP_KERNEL);
+		if (wr == NULL)
+			break;
+		if (wr_init_one(sock, wr) < 0) {
+			kfree(wr);
+			/* it is not a fatal, try next one */
+		}
+
+		wr_put(sock, wr);
+	}
+
+	/* have one or more TX ready */
+	return i > 0;
+}
+
+void wr_fini(struct IB_SOCK *sock)
+{
+	struct ib_sock_wr *wr, *next;
+
+	/* XXX protect */
+	list_for_each_entry_safe(wr, next, &sock->is_wr_idle_list, isw_link) {
+		list_del(&wr->isw_link);
+		wr_destroy_one(wr);
+	}
+	
+	BUG_ON(!list_empty(&sock->is_wr_active_list));
+}
