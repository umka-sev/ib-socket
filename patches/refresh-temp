Bottom: e8cc222994a5c259ce93dc5f887e9f3f5a4dee22
Top:    c5ba1d05b50a037c1cf5a27401d0276cca95fc3c
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-01-21 09:50:58 +0300

Refresh of control-msg.patch

---

diff --git a/ib-sock-ctl.c b/ib-sock-ctl.c
index 9441486..3518a17 100644
--- a/ib-sock-ctl.c
+++ b/ib-sock-ctl.c
@@ -12,6 +12,7 @@ static bool __take_free_ctl(struct IB_SOCK *sock, struct ib_sock_ctl **msg)
 
 		*msg = _msg;
 	}
+	spin_unlock(&sock->is_ctl_lock);
 
 	return _msg != NULL;
 }
@@ -22,22 +23,36 @@ ib_sock_ctl_take(struct IB_SOCK *sock)
 {
 	struct ib_sock_ctl *msg;
 
-       /* take an IDLE TX, if none available - try to allocated one
-        * with new WR index  */
-       wait_event(sock->is_ctl_waitq, __take_free_ctl(sock, &msg));
-       if (msg == NULL)
-               return NULL;
+	/* take an IDLE TX, if none available - try to allocated one
+	 * with new WR index  */
+	wait_event(sock->is_ctl_waitq, __take_free_ctl(sock, &msg));
+	if (msg == NULL)
+		return NULL;
 
 	return msg;
-
 }
 
+/* write related control messages should be return to idle list,
+ * but read related messages need post to addapter to wait incomming data 
+ */
+ 
+/*
+ * modern IB cards have a suggestion to use a SRQ (shared receiver queue)
+ * it will adds latter, so extract base code to own function.
+ */
+int ib_sock_ctl_post(struct IB_SOCK *sock, struct ib_sock_ctl *msg)
+{
+	return 0;
+}
+ 
 void ib_sock_ctl_put(struct IB_SOCK *sock, struct ib_sock_ctl *msg)
 {
+	spin_lock(&sock->is_ctl_lock);
 	list_add(&msg->iscm_link, &sock->is_ctl_idle_list);
+	spin_unlock(&sock->is_ctl_lock);
+
 	wake_up(&sock->is_ctl_waitq);
 }
-struct kmem_cache *ib_sock_ctl;
 
 int ib_sock_ctl_init(struct IB_SOCK *sock)
 {
@@ -45,33 +60,40 @@ int ib_sock_ctl_init(struct IB_SOCK *sock)
 	unsigned int i;
 	unsigned count = 0;
 
-
-	ib_sock_ctl = kmem_cache_create("ib_sock_ctl_msg",
-					  sizeof(struct ib_sock_ctl),
-					  0, SLAB_HWCACHE_ALIGN,
-					  NULL);
-	if (ib_sock_ctl == NULL)
-		return -ENOMEM;
-
 	init_waitqueue_head(&sock->is_ctl_waitq);
 	INIT_LIST_HEAD(&sock->is_ctl_active_list);
 	INIT_LIST_HEAD(&sock->is_ctl_idle_list);
-	
+
 	/* preallocate until limit.
-	 * we can allocate it by request, but simplify a code 
+	 * we can allocate it by request, but simplify a code
 	 */
 	for (i = 0; i < IB_MAX_CTL_MSG; i ++) {
-		msg = kmem_cache_alloc(ib_sock_ctl, GFP_KERNEL);
+		msg = kmalloc(sizeof(*msg), GFP_KERNEL);
 		if (msg == NULL)
 			continue;
 		count ++;
 		/* pre init */
-
+		ib_sock_ctl_put(sock, msg);
+	}
+	/* half of mgs uses for incomming, half outgoning */
+	count /= 2;
+	for(i = 0; i < count; i++) { 
+		msg = ib_sock_ctl_take(sock);
+		ib_sock_ctl_post(sock, msg);
 	}
+
 	return 0;
 }
 
 void ib_sock_ctl_fini(struct IB_SOCK *sock)
 {
-	
-}
\ No newline at end of file
+	struct ib_sock_ctl *pos, *next;
+
+	/* XXX flush active */
+
+	list_for_each_entry_safe(pos, next, &sock->is_ctl_idle_list, iscm_link) {
+		list_del(&pos->iscm_link);
+
+		kfree(pos);
+	}
+}
diff --git a/ib-sock-int.h b/ib-sock-int.h
index 71fc6cf..b87c488 100644
--- a/ib-sock-int.h
+++ b/ib-sock-int.h
@@ -85,23 +85,28 @@ struct ib_hello {
 	__u32	magic;
 } WIRE_ATTR;
 
-/************* ib sock control protocol ***************************/
 #define IB_CTL_MSG_MAGIC	0x87154
 
 struct ib_sock_wire_msg {
 	uint32_t	sww_magic;
 } WIRE_ATTR;
 
+/**************************** messages on wire ********************/
+
+/************* ib sock control protocol ***************************/
+
 struct ib_sock_ctl {
 	struct list_head	iscm_link;
 
+	/* per MAD code we don't need sge at memory, but
+	 * we need a dma address instead. Lets do it optimization
+	 * later */
 	struct ib_sge		iscm_sge;
 
 	/* used to describe an incomming rdma transfer,
 	 * must be first WR in sending chain */
 	struct ib_sock_wire_msg	iscm_msg;
 };
-/************* ib sock control protocol ***************************/
 /* ctl-msg.c */
 /* init queue and post sort of rx buffer to wait incomming data */
 int ib_sock_ctl_msg_init(struct IB_SOCK *sock);
