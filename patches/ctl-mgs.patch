Bottom: 4fdac40b93cac58dc6e13455190cf5badb361b2b
Top:    729121d3fa01a451adc05b5e850a059edd49d552
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-01-16 21:11:03 +0300

IB don't provide generic way to know about transfer.
So we need to define a some control protocol to notify peer about
transfer.
One of two ways may choosed for it.
1) use a generic send / recv functions
2) use MAD (CM) message to exchange a transfer parameters.

use a (1) for initial implementation.

part I - init transfer related structures

IB uses QP - queue pair to transfer data between nodes.
CP is completion pair - transmission events callback.
Control messages uses an global memory region with predefined
key to mark an transfer.


---

diff --git a/Makefile b/Makefile
index 590400a..313194f 100644
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,7 @@
 ifneq ($(KERNELRELEASE),)
     obj-m	:= netsrv.o netcli.o
     obj_ib-y	:= ib-sock.o ib-sock-util.o
+    obj_ib-y	+= ib-sock-mem.o
     netsrv-objs	:= srv.o $(obj_ib-y)
     netcli-objs	:= cli.o $(obj_ib-y)
 else
diff --git a/ib-sock-int.h b/ib-sock-int.h
index c978399..653cec8 100644
--- a/ib-sock-int.h
+++ b/ib-sock-int.h
@@ -7,6 +7,8 @@
 #include <rdma/ib_verbs.h>
 #include <rdma/rdma_cm.h>
 
+#define IB_CQ_EVENTS_MAX 128
+
 #define IB_ADDR_TIMEOUT 100
 #define IB_ROUTE_TIMEOUT 100
 
@@ -17,6 +19,19 @@ enum ib_sock_flags {
 	SOCK_ERROR	= 1 << 1,
 };
 
+struct ib_sock_mem {
+	/* protection domain */
+	struct ib_pd		*ism_pd;
+	/* memory window to map.
+	 * all ? or most cards may work with single == global MR  */
+	struct ib_mr		*ism_mr;
+	
+	/* # send work items for single transfer */
+	unsigned		ism_wr_count;
+	/* ...and their memory */
+	unsigned		ism_sge_count;
+};
+
 struct IB_SOCK {
 	/* primary OFED stack ID */
 	struct rdma_cm_id	*is_id;
@@ -38,7 +53,6 @@ void sock_event_set(struct IB_SOCK *sock, unsigned int event)
 	wake_up(&sock->is_events_wait);
 }
 
-
 /* messages on wire */
 #define WIRE_ATTR	__attribute__((packed))
 
@@ -49,6 +63,11 @@ struct ib_hello {
 } WIRE_ATTR;
 
 
+/* mem.c */
+/* init function responsible to fill an number WR / SGE per socket*/
+int ib_sock_mem_init(struct IB_SOCK *sock);
+void ib_sock_mem_fini(struct IB_SOCK *sock);
+
 
 /* util.c */
 const char *ib_event_type_str(enum ib_event_type ev_type);
diff --git a/ib-sock-mem.c b/ib-sock-mem.c
new file mode 100644
index 0000000..54d8230
--- /dev/null
+++ b/ib-sock-mem.c
@@ -0,0 +1,56 @@
+#include "ib-sock-int.h"
+
+/* it may done for device only (not per connection base) */
+static int ib_sock_mem_init_common(struct IB_SOCK *sock)
+{
+	int 	ret;
+	int	access_flags = IB_ACCESS_LOCAL_WRITE |
+				IB_ACCESS_REMOTE_WRITE;
+
+	/* create a protection domain. */
+	sock->is_mem.ism_pd = ib_alloc_pd(sock->is_id->device);
+	if (IS_ERR(sock->is_mem.ism_pd)) {
+		printk("can't create a protection domain\n");
+		ret = PTR_ERR(sock->is_mem.ism_pd);
+		sock->is_mem.ism_pd = NULL;
+		return ret;
+	}
+
+	sock->is_mem.ism_mr = ib_get_dma_mr(sock->is_mem.ism_pd, access_flags);
+	if (IS_ERR(sock->is_mem.ism_mr)) {
+		ret = PTR_ERR(sock->is_mem.ism_mr);
+		sock->is_mem.ism_mr = NULL;
+		printk("Failed ib_get_dma_mr : %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void ib_sock_mem_fini_common(struct IB_SOCK *sock)
+{
+	if (sock->is_mem.ism_mr)
+		ib_dereg_mr(sock->is_mem.ism_mr);
+
+	if (sock->is_mem.ism_pd)
+		ib_dealloc_pd(sock->is_mem.ism_pd);
+}
+
+int ib_sock_mem_init(struct IB_SOCK *sock)
+{
+	int i;
+	int ret;
+
+	ret = ib_sock_mem_init_common(sock);
+	if (ret < 0)
+		return ret;
+
+	/* different memory managment models may need different init */
+
+	return 0;
+}
+
+void ib_sock_mem_fini(struct IB_SOCK *sock)
+{
+	ib_sock_mem_fini_common(sock);
+}
