Bottom: fd856c0ce4f708032ba5a33272d759bbd390e2bd
Top:    6ba620c1e5b6053cf9674940d783110d9f2451bc
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-01-21 10:12:50 +0300

attach control message to IB

use IB verbs api to attach control messages
to incomming ring.
Send ctl mgs on wire to verify recv code works



---

diff --git a/ib-sock-ctl.c b/ib-sock-ctl.c
index 4f35dcd..1811e59 100644
--- a/ib-sock-ctl.c
+++ b/ib-sock-ctl.c
@@ -42,7 +42,21 @@ ib_sock_ctl_take(struct IB_SOCK *sock)
  */
 int ib_sock_ctl_post(struct IB_SOCK *sock, struct ib_sock_ctl *msg)
 {
-	return 0;
+	/* base on ib_mad_post_receive_mads() - that wr isn't need to live any time 
+	 * so - save memory and declare on stack.
+	 */
+	struct ib_recv_wr wr;
+	struct ib_recv_wr *bad_wr;
+	int ret;
+
+	wr.next = NULL;
+//	wr.wr_id = id | SDP_OP_RECV;
+	wr.sg_list = &msg->iscm_sge;
+	wr.num_sge = 1;
+
+	ret = ib_post_recv(sock->is_qp, &wr, &bad_wr);
+
+	return ret;
 }
  
 void ib_sock_ctl_put(struct IB_SOCK *sock, struct ib_sock_ctl *msg)
@@ -54,6 +68,33 @@ void ib_sock_ctl_put(struct IB_SOCK *sock, struct ib_sock_ctl *msg)
 	wake_up(&sock->is_ctl_waitq);
 }
 
+static int 
+ctl_msg_init(struct IB_SOCK *sock, struct ib_sock_ctl *msg)
+{
+	struct ib_device *device = sock->is_id->device;
+	unsigned long dma_addr;
+
+	dma_addr = ib_dma_map_single(device, (void *)&msg->iscm_msg,
+				sizeof(msg->iscm_msg), DMA_FROM_DEVICE);
+	if (ib_dma_mapping_error(device, dma_addr))
+		return -EIO;
+
+	msg->iscm_sge.addr = dma_addr;
+	msg->iscm_sge.length = sizeof(msg->iscm_msg);
+	msg->iscm_sge.lkey   = sock->is_mem.ism_mr->lkey;
+
+	return 0;
+}
+
+static void
+ctl_msg_fini(struct IB_SOCK *sock, struct ib_sock_ctl *msg)
+{
+	struct ib_device *device = sock->is_id->device;
+
+	ib_dma_unmap_single(device, msg->iscm_sge.addr,
+			    sizeof(msg->iscm_msg), DMA_FROM_DEVICE);
+}
+
 int ib_sock_ctl_init(struct IB_SOCK *sock)
 {
 	struct ib_sock_ctl *msg;
@@ -71,8 +112,12 @@ int ib_sock_ctl_init(struct IB_SOCK *sock)
 		msg = kmalloc(sizeof(*msg), GFP_KERNEL);
 		if (msg == NULL)
 			continue;
-		count ++;
 		/* pre init */
+		if (ctl_msg_init(sock, msg) != 0) {
+			kfree(msg);
+			continue;
+		}
+		count ++;
 		ib_sock_ctl_put(sock, msg);
 	}
 	/* half of mgs uses for incomming, half outgoning */
@@ -89,7 +134,7 @@ void ib_sock_ctl_fini(struct IB_SOCK *sock)
 {
 	struct ib_sock_ctl *pos, *next;
 
-	/* XXX flush active */
+	/* XXX cancel active */
 	list_for_each_entry_safe(pos, next, &sock->is_ctl_active_list, iscm_link) {
 		list_del(&pos->iscm_link);
 		list_add(&pos->iscm_link, &sock->is_ctl_idle_list);
@@ -97,6 +142,7 @@ void ib_sock_ctl_fini(struct IB_SOCK *sock)
 
 	list_for_each_entry_safe(pos, next, &sock->is_ctl_idle_list, iscm_link) {
 		list_del(&pos->iscm_link);
+		ctl_msg_fini(sock, pos);
 
 		kfree(pos);
 	}
