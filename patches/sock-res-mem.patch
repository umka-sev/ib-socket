Bottom: 2a7eacc1e6c09814fbee6b15d25e417561dd2ff4
Top:    2cfb757104584fff507d00e92ecfec2fda95b5db
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-01-16 21:11:03 +0300

IB don't provide generic way to know about transfer.
So we need to define a some control protocol to notify peer about
transfer.
One of two ways may choosed for it.
1) use a generic send / recv functions
2) use MAD (CM) message to exchange a transfer parameters.

use a (1) for initial implementation.

part I - init transfer related structures

IB uses QP - queue pair to transfer data between nodes.
CP is completion pair - transmission events callback.
Control messages uses an global memory region with predefined
key to mark an transfer.


---

diff --git a/Makefile b/Makefile
index 590400a..313194f 100644
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,7 @@
 ifneq ($(KERNELRELEASE),)
     obj-m	:= netsrv.o netcli.o
     obj_ib-y	:= ib-sock.o ib-sock-util.o
+    obj_ib-y	+= ib-sock-mem.o
     netsrv-objs	:= srv.o $(obj_ib-y)
     netcli-objs	:= cli.o $(obj_ib-y)
 else
diff --git a/ib-sock-int.h b/ib-sock-int.h
index d2a1904..18092c2 100644
--- a/ib-sock-int.h
+++ b/ib-sock-int.h
@@ -17,12 +17,22 @@ enum ib_sock_flags {
 	SOCK_ERROR	= 1 << 1,
 };
 
+struct ib_sock_mem {
+	/* protection domain */
+	struct ib_pd		*ism_pd;
+	/* memory window to map.
+	 * all ? or most cards may work with single == global MR  */
+	struct ib_mr		*ism_mr;
+};
+
 struct IB_SOCK {
 	/* primary OFED stack ID */
 	struct rdma_cm_id	*is_id;
 
 	unsigned long		is_flags;
 
+	struct ib_sock_mem	is_mem;
+
 	/* pre-accepted sockets */
 	spinlock_t		is_child_lock;
 	struct list_head	is_child;
@@ -39,7 +49,6 @@ void sock_event_set(struct IB_SOCK *sock, unsigned int event)
 	wake_up(&sock->is_events_wait);
 }
 
-
 /* messages on wire */
 #define WIRE_ATTR	__attribute__((packed))
 
@@ -50,6 +59,11 @@ struct ib_hello {
 } WIRE_ATTR;
 
 
+/* mem.c */
+/* init function responsible to fill an number WR / SGE per socket*/
+int ib_sock_mem_init(struct IB_SOCK *sock);
+void ib_sock_mem_fini(struct IB_SOCK *sock);
+
 
 /* util.c */
 const char *ib_event_type_str(enum ib_event_type ev_type);
diff --git a/ib-sock-mem.c b/ib-sock-mem.c
new file mode 100644
index 0000000..4976a3f
--- /dev/null
+++ b/ib-sock-mem.c
@@ -0,0 +1,55 @@
+#include "ib-sock-int.h"
+
+/* it may done for device only (not per connection base) */
+static int ib_sock_mem_init_common(struct IB_SOCK *sock)
+{
+	int 	ret;
+	int	access_flags = IB_ACCESS_LOCAL_WRITE |
+				IB_ACCESS_REMOTE_WRITE;
+
+	/* create a protection domain. */
+	sock->is_mem.ism_pd = ib_alloc_pd(sock->is_id->device);
+	if (IS_ERR(sock->is_mem.ism_pd)) {
+		printk("can't create a protection domain\n");
+		ret = PTR_ERR(sock->is_mem.ism_pd);
+		sock->is_mem.ism_pd = NULL;
+		return ret;
+	}
+
+	sock->is_mem.ism_mr = ib_get_dma_mr(sock->is_mem.ism_pd, access_flags);
+	if (IS_ERR(sock->is_mem.ism_mr)) {
+		ret = PTR_ERR(sock->is_mem.ism_mr);
+		sock->is_mem.ism_mr = NULL;
+		printk("Failed ib_get_dma_mr : %d\n", ret);
+		return ret;
+	}
+
+	return 0;
+}
+
+static void ib_sock_mem_fini_common(struct IB_SOCK *sock)
+{
+	if (sock->is_mem.ism_mr)
+		ib_dereg_mr(sock->is_mem.ism_mr);
+
+	if (sock->is_mem.ism_pd)
+		ib_dealloc_pd(sock->is_mem.ism_pd);
+}
+
+int ib_sock_mem_init(struct IB_SOCK *sock)
+{
+	int ret;
+
+	ret = ib_sock_mem_init_common(sock);
+	if (ret < 0)
+		return ret;
+
+	/* different memory managment models may need different init */
+
+	return 0;
+}
+
+void ib_sock_mem_fini(struct IB_SOCK *sock)
+{
+	ib_sock_mem_fini_common(sock);
+}
diff --git a/ib-sock.c b/ib-sock.c
index 1816baa..fe58881 100644
--- a/ib-sock.c
+++ b/ib-sock.c
@@ -1,8 +1,26 @@
 #include "ib-sock.h"
 #include "ib-sock-int.h"
 
-struct IB_SOCK *__ib_socket_create(struct rdma_cm_id *cm_id);
+static struct IB_SOCK *__ib_socket_create(struct rdma_cm_id *cm_id);
 
+/* allocate a sort of resources for socket, such as 
+ * 1) memory region to map a requests
+ */
+static int ib_sock_resource_alloc(struct IB_SOCK *sock)
+{
+	int ret;
+
+	ret = ib_sock_mem_init(sock);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+static void ib_sock_resource_free(struct IB_SOCK *sock)
+{
+	ib_sock_mem_fini(sock);
+}
 
 static int
 cm_client_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
@@ -59,6 +77,11 @@ cm_client_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 			break;
 		}
 
+		/* connect response done, hello verified - allocate resources and go */
+		ret = ib_sock_resource_alloc(sock);
+		if (ret < 0)
+			break;
+
 		sock_event_set(sock, POLLOUT);
 		break;
 	}
@@ -71,6 +94,13 @@ cm_client_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 	return ret;
 }
 /**************************************************************************************/
+static void server_error_accept(struct IB_SOCK *sock)
+{
+	/* will destroy after exit from event cb */
+	sock->is_id = NULL;
+	ib_socket_destroy(sock);
+}
+
 static int
 cm_server_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 {
@@ -94,12 +124,18 @@ cm_server_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 		}
 
 		sock = __ib_socket_create(cmid);
-		if (sock != NULL) {
+		if (sock == NULL) {
 			printk("error accept \n");
 			ret = -ENOMEM;
 			break;
 		}
 
+		ret = ib_sock_resource_alloc(sock);
+		if (ret < 0) {
+			server_error_accept(sock);
+			return ret;
+		}
+
 		memset(&hello_ack, 0, sizeof hello_ack);
 		hello_ack.magic = IB_HELLO_MAGIC;
 
@@ -112,9 +148,7 @@ cm_server_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 
 		ret = rdma_accept(sock->is_id, &conn_param);
 		if (ret < 0) {
-			/* will destroy after exit from event cb */
-			sock->is_id = NULL;
-			ib_socket_destroy(sock);
+			server_error_accept(sock);
 			return ret;
 		}
 
@@ -251,6 +285,8 @@ void ib_socket_destroy(struct IB_SOCK *sock)
 		ib_socket_destroy(pos);
 	}
 
+	ib_sock_resource_free(sock);
+
 	if (sock->is_id)
 		rdma_destroy_id(sock->is_id);
 	kfree(sock);
