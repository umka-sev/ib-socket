Bottom: ccc0c810e2395e501642fd53f9432ea1045cac64
Top:    c5ba1d05b50a037c1cf5a27401d0276cca95fc3c
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-01-18 21:42:27 +0300

IB don't have own notification about transfers, 
so expect each consumer will implement an own protocol.
lets add a dma premapped messages to ability to transfer 
or fill with incomming data.


---

diff --git a/Makefile b/Makefile
index 313194f..08d99d2 100644
--- a/Makefile
+++ b/Makefile
@@ -1,7 +1,7 @@
 ifneq ($(KERNELRELEASE),)
     obj-m	:= netsrv.o netcli.o
     obj_ib-y	:= ib-sock.o ib-sock-util.o
-    obj_ib-y	+= ib-sock-mem.o
+    obj_ib-y	+= ib-sock-mem.o ib-sock-ctl.o
     netsrv-objs	:= srv.o $(obj_ib-y)
     netcli-objs	:= cli.o $(obj_ib-y)
 else
diff --git a/ib-sock-ctl.c b/ib-sock-ctl.c
new file mode 100644
index 0000000..3518a17
--- /dev/null
+++ b/ib-sock-ctl.c
@@ -0,0 +1,99 @@
+#include "ib-sock-int.h"
+
+static bool __take_free_ctl(struct IB_SOCK *sock, struct ib_sock_ctl **msg)
+{
+	struct ib_sock_ctl *_msg;
+
+	spin_lock(&sock->is_ctl_lock);
+	_msg = list_first_entry_or_null(&sock->is_ctl_idle_list,
+					struct ib_sock_ctl, iscm_link);
+	if (_msg != NULL) {
+		list_move(&_msg->iscm_link, &sock->is_ctl_active_list);
+
+		*msg = _msg;
+	}
+	spin_unlock(&sock->is_ctl_lock);
+
+	return _msg != NULL;
+}
+
+/* take from idle list or wait until free exist */
+struct ib_sock_ctl *
+ib_sock_ctl_take(struct IB_SOCK *sock)
+{
+	struct ib_sock_ctl *msg;
+
+	/* take an IDLE TX, if none available - try to allocated one
+	 * with new WR index  */
+	wait_event(sock->is_ctl_waitq, __take_free_ctl(sock, &msg));
+	if (msg == NULL)
+		return NULL;
+
+	return msg;
+}
+
+/* write related control messages should be return to idle list,
+ * but read related messages need post to addapter to wait incomming data 
+ */
+ 
+/*
+ * modern IB cards have a suggestion to use a SRQ (shared receiver queue)
+ * it will adds latter, so extract base code to own function.
+ */
+int ib_sock_ctl_post(struct IB_SOCK *sock, struct ib_sock_ctl *msg)
+{
+	return 0;
+}
+ 
+void ib_sock_ctl_put(struct IB_SOCK *sock, struct ib_sock_ctl *msg)
+{
+	spin_lock(&sock->is_ctl_lock);
+	list_add(&msg->iscm_link, &sock->is_ctl_idle_list);
+	spin_unlock(&sock->is_ctl_lock);
+
+	wake_up(&sock->is_ctl_waitq);
+}
+
+int ib_sock_ctl_init(struct IB_SOCK *sock)
+{
+	struct ib_sock_ctl *msg;
+	unsigned int i;
+	unsigned count = 0;
+
+	init_waitqueue_head(&sock->is_ctl_waitq);
+	INIT_LIST_HEAD(&sock->is_ctl_active_list);
+	INIT_LIST_HEAD(&sock->is_ctl_idle_list);
+
+	/* preallocate until limit.
+	 * we can allocate it by request, but simplify a code
+	 */
+	for (i = 0; i < IB_MAX_CTL_MSG; i ++) {
+		msg = kmalloc(sizeof(*msg), GFP_KERNEL);
+		if (msg == NULL)
+			continue;
+		count ++;
+		/* pre init */
+		ib_sock_ctl_put(sock, msg);
+	}
+	/* half of mgs uses for incomming, half outgoning */
+	count /= 2;
+	for(i = 0; i < count; i++) { 
+		msg = ib_sock_ctl_take(sock);
+		ib_sock_ctl_post(sock, msg);
+	}
+
+	return 0;
+}
+
+void ib_sock_ctl_fini(struct IB_SOCK *sock)
+{
+	struct ib_sock_ctl *pos, *next;
+
+	/* XXX flush active */
+
+	list_for_each_entry_safe(pos, next, &sock->is_ctl_idle_list, iscm_link) {
+		list_del(&pos->iscm_link);
+
+		kfree(pos);
+	}
+}
diff --git a/ib-sock-int.h b/ib-sock-int.h
index c6bcecf..b87c488 100644
--- a/ib-sock-int.h
+++ b/ib-sock-int.h
@@ -16,7 +16,8 @@
 #define IB_MAX_PARALLEL	 1
 
 /* 1 RX + 1 TX in flight */
-#define IB_CQ_EVENTS_MAX (IB_MAX_PARALLEL) * 2
+#define IB_MAX_CTL_MSG	(IB_MAX_PARALLEL * 2)
+#define IB_CQ_EVENTS_MAX (IB_MAX_PARALLEL * 2)
 
 enum ib_sock_flags {
 	SOCK_CONNECTED	= 1 << 0,
@@ -52,6 +53,13 @@ struct IB_SOCK {
 	/* queue pair to communicate between nodes */
 	struct ib_qp		*is_qp;
 
+	/* control messages */
+	/* IDLE <> active protection  */
+	spinlock_t		is_ctl_lock;
+	struct list_head	is_ctl_idle_list;
+	struct list_head	is_ctl_active_list;
+	wait_queue_head_t	is_ctl_waitq;
+
 	/* pre-accepted sockets */
 	spinlock_t		is_child_lock;
 	struct list_head	is_child;
@@ -68,7 +76,7 @@ void sock_event_set(struct IB_SOCK *sock, unsigned int event)
 	wake_up(&sock->is_events_wait);
 }
 
-/* messages on wire */
+/**************************** messages on wire ********************/
 #define WIRE_ATTR	__attribute__((packed))
 
 #define IB_HELLO_MAGIC 0x9012
@@ -77,6 +85,34 @@ struct ib_hello {
 	__u32	magic;
 } WIRE_ATTR;
 
+#define IB_CTL_MSG_MAGIC	0x87154
+
+struct ib_sock_wire_msg {
+	uint32_t	sww_magic;
+} WIRE_ATTR;
+
+/**************************** messages on wire ********************/
+
+/************* ib sock control protocol ***************************/
+
+struct ib_sock_ctl {
+	struct list_head	iscm_link;
+
+	/* per MAD code we don't need sge at memory, but
+	 * we need a dma address instead. Lets do it optimization
+	 * later */
+	struct ib_sge		iscm_sge;
+
+	/* used to describe an incomming rdma transfer,
+	 * must be first WR in sending chain */
+	struct ib_sock_wire_msg	iscm_msg;
+};
+/* ctl-msg.c */
+/* init queue and post sort of rx buffer to wait incomming data */
+int ib_sock_ctl_msg_init(struct IB_SOCK *sock);
+void ib_sock_ctl_msg_fini(struct IB_SOCK *sock);
+/* take control message to send an outgoning buffer */
+struct ib_sock_ctl *ib_sock_ctl_idle_take(struct IB_SOCK *sock);
 
 /* mem.c */
 /* init function responsible to fill an number WR / SGE per socket*/
diff --git a/ib-sock.h b/ib-sock.h
index 0a2f9a9..c74c3df 100644
--- a/ib-sock.h
+++ b/ib-sock.h
@@ -28,5 +28,7 @@ unsigned long ib_socket_poll(struct IB_SOCK *sock);
 int ib_socket_bind(struct IB_SOCK *sock, uint32_t addr, unsigned port);
 struct IB_SOCK *ib_socket_accept(struct IB_SOCK *parent);
 
+/* send some amount data over wire */
+size_t ib_socket_write(struct IB_SOCK *sock, void *buf, size_t size);
 
 #endif
\ No newline at end of file
