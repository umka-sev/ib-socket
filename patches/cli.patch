Bottom: 199c14b7301f83f79b686d1d464572735fbe2db9
Top:    7411129e6c92aae16c859c12b7fd9fd8999a12c3
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-01-14 11:49:20 +0300

connect ib socket to the destination.
It's not easy as traditional socket API,
we need to create resourses ourself and
wait until address + route will resolved.


---

diff --git a/Makefile b/Makefile
index 21ac7e7..590400a 100644
--- a/Makefile
+++ b/Makefile
@@ -1,6 +1,6 @@
 ifneq ($(KERNELRELEASE),)
     obj-m	:= netsrv.o netcli.o
-    obj_ib-y	:= ib-sock.o 
+    obj_ib-y	:= ib-sock.o ib-sock-util.o
     netsrv-objs	:= srv.o $(obj_ib-y)
     netcli-objs	:= cli.o $(obj_ib-y)
 else
diff --git a/cli.c b/cli.c
index e4d0f59..b6deb50 100644
--- a/cli.c
+++ b/cli.c
@@ -1,7 +1,9 @@
 #include "ib-sock.h"
 
-static unsigned int port = 10000;
-const char *srv_addr = "192.168.1.1";
+#include <linux/delay.h>
+
+static unsigned int port = 998;
+const char *srv_addr = "172.18.56.132";
 static __u32 addr  = 0;
 
 
@@ -9,11 +11,36 @@ static int __init
 cli_init(void)
 {
 	struct IB_SOCK *sock;
+	unsigned a,b,c,d;
+	struct sockaddr_in  dstaddr;
+	unsigned long event;
+	int err;
+
+	/* numeric IP? */
+	if (sscanf(srv_addr, "%u.%u.%u.%u", &a, &b, &c, &d) != 4)
+		return -EINVAL;
+
+	addr = ((a<<24)|(b<<16)|(c<<8)|d);
 
 	sock = ib_socket_create();
 	if (sock == NULL)
 		return -ENOMEM;
 
+	memset(&dstaddr, 0, sizeof(dstaddr));
+	dstaddr.sin_family = AF_INET;
+	dstaddr.sin_addr.s_addr = htonl(addr);
+	dstaddr.sin_port = htons(port);
+
+	err = ib_socket_connect(sock, &dstaddr);
+	if (err) {
+		printk("error connect \n");
+		goto exit;
+	}
+	event = ib_socket_poll(sock);
+	printk("Event hit %lx\n", event);
+
+	ib_socket_disconnect(sock);
+exit:
 	ib_socket_destroy(sock);
 	return 0;
 }
@@ -26,4 +53,4 @@ cli_cleanup(void)
 module_init(cli_init);
 module_exit(cli_cleanup);
 
-MODULE_LICENSE("GPL");
\ No newline at end of file
+MODULE_LICENSE("GPL");
diff --git a/ib-sock-int.h b/ib-sock-int.h
index e5f19fc..add0b53 100644
--- a/ib-sock-int.h
+++ b/ib-sock-int.h
@@ -7,9 +7,47 @@
 #include <rdma/ib_verbs.h>
 #include <rdma/rdma_cm.h>
 
+#define IB_ADDR_TIMEOUT 100
+#define IB_ROUTE_TIMEOUT 100
+
+enum ib_sock_flags {
+	SOCK_CONNECTED	= 1 << 0,
+	SOCK_ERROR	= 1 << 1,
+};
+
 struct IB_SOCK {
 	/* primary OFED stack ID */
 	struct rdma_cm_id	*is_id;
+
+	unsigned long		is_flags;
+
+	/* event mask */
+	unsigned long		is_events;
+	wait_queue_head_t	is_events_wait;
 };
 
+static inline
+void sock_event_set(struct IB_SOCK *sock, unsigned int event)
+{
+	sock->is_events |= event;
+	wake_up(&sock->is_events_wait);
+}
+
+
+/* messages on wire */
+#define WIRE_ATTR	__attribute__((packed))
+
+#define IB_HELLO_MAGIC 0x9012
+
+struct ib_hello {
+	__u32	magic;
+} WIRE_ATTR;
+
+
+
+/* util.c */
+const char *ib_event_type_str(enum ib_event_type ev_type);
+const char *wr_status_str(enum ib_wc_status status);
+char *cm_event_type_str(enum rdma_cm_event_type ev_type);
+
 #endif
diff --git a/ib-sock-util.c b/ib-sock-util.c
new file mode 100644
index 0000000..fc2e6e1
--- /dev/null
+++ b/ib-sock-util.c
@@ -0,0 +1,160 @@
+#include "ib-sock.h"
+#include "ib-sock-int.h"
+
+const char *ib_event_type_str(enum ib_event_type ev_type)
+{
+	switch (ev_type) {
+	case IB_EVENT_COMM_EST:
+		return "COMM_EST";
+	case IB_EVENT_QP_FATAL:
+		return "QP_FATAL";
+	case IB_EVENT_QP_REQ_ERR:
+		return "QP_REQ_ERR";
+	case IB_EVENT_QP_ACCESS_ERR:
+		return "QP_ACCESS_ERR";
+	case IB_EVENT_SQ_DRAINED:
+		return "SQ_DRAINED";
+	case IB_EVENT_PATH_MIG:
+		return "PATH_MIG";
+	case IB_EVENT_PATH_MIG_ERR:
+		return "PATH_MIG_ERR";
+	case IB_EVENT_QP_LAST_WQE_REACHED:
+		return "QP_LAST_WQE_REACHED";
+	case IB_EVENT_CQ_ERR:
+		return "CQ_ERR";
+	case IB_EVENT_SRQ_ERR:
+		return "SRQ_ERR";
+	case IB_EVENT_SRQ_LIMIT_REACHED:
+		return "SRQ_LIMIT_REACHED";
+	case IB_EVENT_PORT_ACTIVE:
+		return "PORT_ACTIVE";
+	case IB_EVENT_PORT_ERR:
+		return "PORT_ERR";
+	case IB_EVENT_LID_CHANGE:
+		return "LID_CHANGE";
+	case IB_EVENT_PKEY_CHANGE:
+		return "PKEY_CHANGE";
+	case IB_EVENT_SM_CHANGE:
+		return "SM_CHANGE";
+	case IB_EVENT_CLIENT_REREGISTER:
+		return "CLIENT_REREGISTER";
+	case IB_EVENT_DEVICE_FATAL:
+		return "DEVICE_FATAL";
+	default:
+		return "UNKNOWN";
+	}
+}
+
+const char *wr_status_str(enum ib_wc_status status)
+{
+	switch (status) {
+	case IB_WC_SUCCESS:
+		return "WC_SUCCESS";
+
+	case IB_WC_LOC_LEN_ERR:
+		return "WC_LOC_LEN_ERR";
+
+	case IB_WC_LOC_QP_OP_ERR:
+		return "WC_LOC_QP_OP_ERR";
+
+	case IB_WC_LOC_EEC_OP_ERR:
+		return "WC_LOC_EEC_OP_ERR";
+
+	case IB_WC_LOC_PROT_ERR:
+		return "WC_LOC_PROT_ERR";
+
+	case IB_WC_WR_FLUSH_ERR:
+		return "WC_WR_FLUSH_ERR";
+
+	case IB_WC_MW_BIND_ERR:
+		return "WC_MW_BIND_ERR";
+
+	case IB_WC_BAD_RESP_ERR:
+		return "WC_BAD_RESP_ERR";
+
+	case IB_WC_LOC_ACCESS_ERR:
+		return "WC_LOC_ACCESS_ERR";
+
+	case IB_WC_REM_INV_REQ_ERR:
+		return "WC_REM_INV_REQ_ERR";
+
+	case IB_WC_REM_ACCESS_ERR:
+		return "WC_REM_ACCESS_ERR";
+
+	case IB_WC_REM_OP_ERR:
+		return "WC_REM_OP_ERR";
+
+	case IB_WC_RETRY_EXC_ERR:
+		return "WC_RETRY_EXC_ERR";
+
+	case IB_WC_RNR_RETRY_EXC_ERR:
+		return "WC_RNR_RETRY_EXC_ERR";
+
+	case IB_WC_LOC_RDD_VIOL_ERR:
+		return "WC_LOC_RDD_VIOL_ERR";
+
+	case IB_WC_REM_INV_RD_REQ_ERR:
+		return "WC_REM_INV_RD_REQ_ERR";
+
+	case IB_WC_REM_ABORT_ERR:
+		return "WC_REM_ABORT_ERR";
+
+	case IB_WC_INV_EECN_ERR:
+		return "WC_INV_EECN_ERR";
+
+	case IB_WC_INV_EEC_STATE_ERR:
+		return "WC_INV_EEC_STATE_ERR";
+
+	case IB_WC_FATAL_ERR:
+		return "WC_FATAL_ERR";
+
+	case IB_WC_RESP_TIMEOUT_ERR:
+		return "WC_RESP_TIMEOUT_ERR";
+
+	case IB_WC_GENERAL_ERR:
+		return "WC_GENERAL_ERR";
+
+	default:
+		return "UNKNOWN";
+	}
+}
+
+char *cm_event_type_str(enum rdma_cm_event_type ev_type)
+{
+	switch (ev_type) {
+	case RDMA_CM_EVENT_ADDR_RESOLVED:
+		return "ADDRESS_RESOLVED";
+	case RDMA_CM_EVENT_ADDR_ERROR:
+		return "ADDESS_ERROR";
+	case RDMA_CM_EVENT_ROUTE_RESOLVED:
+		return "ROUTE_RESOLVED";
+	case RDMA_CM_EVENT_ROUTE_ERROR:
+		return "ROUTE_ERROR";
+	case RDMA_CM_EVENT_CONNECT_REQUEST:
+		return "CONNECT_REQUEST";
+	case RDMA_CM_EVENT_CONNECT_RESPONSE:
+		return "CONNECT_RESPONSE";
+	case RDMA_CM_EVENT_CONNECT_ERROR:
+		return "CONNECT_ERROR";
+	case RDMA_CM_EVENT_UNREACHABLE:
+		return "UNREACHABLE";
+	case RDMA_CM_EVENT_REJECTED:
+		return "REJECTED";
+	case RDMA_CM_EVENT_ESTABLISHED:
+		return "ESTABLISHED";
+	case RDMA_CM_EVENT_DISCONNECTED:
+		return "DISCONNECTED";
+	case RDMA_CM_EVENT_DEVICE_REMOVAL:
+		return "DEVICE_REMOVAL";
+	case RDMA_CM_EVENT_MULTICAST_JOIN:
+		return "MULTICAST_JOIN";
+	case RDMA_CM_EVENT_MULTICAST_ERROR:
+		return "MULTICAST_ERROR";
+	case RDMA_CM_EVENT_ADDR_CHANGE:
+		return "ADDR_CHANGE";
+	case RDMA_CM_EVENT_TIMEWAIT_EXIT:
+		return "TIMEWAIT_EXIT";
+	default:
+		return "UNKNOWN";
+	}
+}
\ No newline at end of file
diff --git a/ib-sock.c b/ib-sock.c
index 1c67337..fa47955 100644
--- a/ib-sock.c
+++ b/ib-sock.c
@@ -1,12 +1,82 @@
 #include "ib-sock.h"
 #include "ib-sock-int.h"
 
+static int
+cm_client_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
+{
+	struct IB_SOCK *sock = cmid->context;
+	int ret = 0;
+
+	switch (event->event) {
+	case RDMA_CM_EVENT_ADDR_RESOLVED:
+		ret = rdma_resolve_route(cmid, IB_ROUTE_TIMEOUT);
+		break;
+	case RDMA_CM_EVENT_ROUTE_RESOLVED: {
+		/* route resolved - need to send an HELLO message */
+		struct rdma_conn_param	conn_param;
+		struct ib_hello	hello;
+
+		memset(&conn_param, 0, sizeof conn_param);
+		conn_param.responder_resources = 4;
+		conn_param.initiator_depth     = 1;
+		conn_param.retry_count	       = 7;
+		conn_param.rnr_retry_count     = 6;
+
+		/* fill a hello message */
+		hello.magic = IB_HELLO_MAGIC;
+		conn_param.private_data		= (void *)&hello;
+		conn_param.private_data_len	= sizeof(struct ib_hello);
+
+		/* we may use a strict IB verbs API to send a hello message
+		 * instead of rdma_ API */
+		ret = rdma_connect(sock->is_id, &conn_param);
+		if (ret)
+			printk("failure connecting: %d\n", ret);
+
+		break;
+	}
+#if 0
+	case RDMA_CM_EVENT_ESTABLISHED:
+		break;
+#endif
+	case RDMA_CM_EVENT_CONNECT_RESPONSE: {
+		/* This event Generated  on  the active side to notify the user of a
+		 * successful response to a connection  request.   It  is
+		 * only  generated  on rdma_cm_id's that do not have a QP
+		 * associated with them.
+		*/
+		/* we delay to create a connection resources until we have
+		 * check a server connect response, it save lots resources
+		 * in case server have a wrong version or capabilites */
+		const struct ib_hello *hello = event->param.conn.private_data;
+
+		sock->is_flags |= SOCK_CONNECTED;
+		if (hello->magic != IB_HELLO_MAGIC) {
+			ret = -EPROTO;
+			break;
+		}
+
+		sock_event_set(sock, POLLOUT);
+		break;
+	}
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	printk("client CM event ret %d\n", ret);
+	return ret;
+}
+
+
 static int cm_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 {
+	struct IB_SOCK *sock = cmid->context;
 	int ret = 0;
 
-	printk("CM event %d status %d conn %p id %p\n",
-		event->event, event->status, cmid->context, cmid);
+	printk("CM event %s status %d conn %p id %p\n",
+		cm_event_type_str(event->event), event->status, cmid->context,
+		cmid);
 
 	switch (event->event) {
 	/* client related events */
@@ -14,6 +84,7 @@ static int cm_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 	case RDMA_CM_EVENT_ROUTE_RESOLVED:
 	case RDMA_CM_EVENT_ESTABLISHED:
 	case RDMA_CM_EVENT_CONNECT_RESPONSE:
+		ret = cm_client_handler(cmid, event);
 		break;
 	/* server related events */
 	case RDMA_CM_EVENT_CONNECT_REQUEST:
@@ -21,9 +92,13 @@ static int cm_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 	/* some common errors */
 	case RDMA_CM_EVENT_ADDR_ERROR:
 	case RDMA_CM_EVENT_ROUTE_ERROR:
-	case RDMA_CM_EVENT_CONNECT_ERROR:
 	case RDMA_CM_EVENT_UNREACHABLE:
+		ret = -EHOSTUNREACH;
+		break;
+	case RDMA_CM_EVENT_CONNECT_ERROR:
 	case RDMA_CM_EVENT_REJECTED:
+		/* to decode a reject event, see srp_cm_rej_handler */
+		ret = -ECONNREFUSED;
 		break;
 	/* some hard errors to abort connection */
 	case RDMA_CM_EVENT_DISCONNECTED:
@@ -32,9 +107,18 @@ static int cm_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 		break;
 	default:
 		printk("Unexpected RDMA CM event (%d)\n", event->event);
+		ret = -EINVAL;
 		break;
 	}
-	return ret;
+
+	if (ret < 0) {
+		sock->is_flags |= SOCK_ERROR;
+		sock_event_set(sock, POLLERR);
+	}
+	/* if we return an error, OFED treat it as critical error and kill an ID,
+	 * dobule destroy id will result a panic. LNet uses it way
+	 * to save a resources. */
+	return 0;
 }
 
 struct IB_SOCK *ib_socket_create()
@@ -49,9 +133,14 @@ struct IB_SOCK *ib_socket_create()
 					     RDMA_PS_TCP, IB_QPT_RC);
 	if (IS_ERR(sock->is_id)) {
 		printk("error create cm_id %ld\n", PTR_ERR(sock->is_id));
+		sock->is_id = NULL;
 		goto out_free;
 	}
 
+	sock->is_flags = 0;
+	sock->is_events = 0;
+	init_waitqueue_head(&sock->is_events_wait);
+	
 	printk("IB socket create %p\n", sock);
 	return sock;
 out_free:
@@ -67,3 +156,71 @@ void ib_socket_destroy(struct IB_SOCK *sock)
 		rdma_destroy_id(sock->is_id);
 	kfree(sock);
 }
+
+/***************************************************************************************/
+/*
+ * In IB terms - connect is resolving address + router + some connect mgs exchange.
+ * all of it done via CM related events.
+ *
+ * IB uses an IP addresses as some ID to resolve in destination GID value.
+ */
+
+int ib_socket_connect(struct IB_SOCK *sock, struct sockaddr_in  *dstaddr)
+{
+	struct sockaddr_in  srcaddr;
+	int err;
+
+        memset(&srcaddr, 0, sizeof(srcaddr));
+        srcaddr.sin_family      = AF_INET;
+
+	/* IB needs to start from resolve addr / route first */
+	err = rdma_resolve_addr(sock->is_id, (struct sockaddr *)&srcaddr,
+			        (struct sockaddr *)dstaddr,
+			        IB_ADDR_TIMEOUT /* timeout ms */
+			        );
+	printk("resolve dst address status %d\n", err);
+
+	/* when connect will done - WRITE event will generated */
+	return err;
+}
+
+void ib_socket_disconnect(struct IB_SOCK *sock)
+{
+	int err = 0;
+
+	/* change the ib conn state only if the conn is UP, however always call
+	 * rdma_disconnect since this is the only way to cause the CM to change
+	 * the QP state to ERROR
+	 */
+
+	if ((sock->is_flags & SOCK_CONNECTED) == 0)
+		return;
+
+	err = rdma_disconnect(sock->is_id);
+	if (err)
+		printk("Failed to disconnect, conn: 0x%p err %d\n",
+			 sock,err);
+}
+
+static unsigned long __take_event(struct IB_SOCK *sock, unsigned long *e)
+{
+	unsigned long events;
+	
+	events = xchg(&sock->is_events, 0);
+	if (events != 0)
+		*e = events;
+
+	return events;
+}
+
+unsigned long ib_socket_poll(struct IB_SOCK *sock)
+{
+	unsigned long mask = 0;
+
+	wait_event(sock->is_events_wait, __take_event(sock, &mask));
+
+	if (sock->is_flags & SOCK_ERROR)
+		mask |= POLLERR;
+
+	return mask;
+}
diff --git a/ib-sock.h b/ib-sock.h
index 96d019b..533e991 100644
--- a/ib-sock.h
+++ b/ib-sock.h
@@ -11,9 +11,18 @@
 #include <linux/socket.h>
 #include <linux/in.h>
 
+#include <linux/poll.h>
+
 struct IB_SOCK;
 
 struct IB_SOCK *ib_socket_create(void);
 void ib_socket_destroy(struct IB_SOCK *sock);
 
+/* async. return POLLOUT or POLLERR events */
+int ib_socket_connect(struct IB_SOCK *sock, struct sockaddr_in  *dstaddr);
+void ib_socket_disconnect(struct IB_SOCK *sock);
+
+/* sleep to wait poll event from socket */
+unsigned long ib_socket_poll(struct IB_SOCK *sock);
+
 #endif
\ No newline at end of file
