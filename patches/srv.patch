Bottom: 7411129e6c92aae16c859c12b7fd9fd8999a12c3
Top:    4fdac40b93cac58dc6e13455190cf5badb361b2b
Author: Alexey Lyashkov <shadow@Alexeys-MacBook-Pro.local>
Date:   2016-01-15 12:45:24 +0300

Introduce a server side code for a socket.
 a) create a server socket
 b) accept an incomming connect request
 c) hello exchange



---

diff --git a/cli.c b/cli.c
index b6deb50..f0bcd39 100644
--- a/cli.c
+++ b/cli.c
@@ -2,7 +2,7 @@
 
 #include <linux/delay.h>
 
-static unsigned int port = 998;
+static unsigned int port = 1998;
 const char *srv_addr = "172.18.56.132";
 static __u32 addr  = 0;
 
diff --git a/ib-sock-int.h b/ib-sock-int.h
index add0b53..c978399 100644
--- a/ib-sock-int.h
+++ b/ib-sock-int.h
@@ -10,6 +10,8 @@
 #define IB_ADDR_TIMEOUT 100
 #define IB_ROUTE_TIMEOUT 100
 
+#define IB_LISTEN_QUEUE 128
+
 enum ib_sock_flags {
 	SOCK_CONNECTED	= 1 << 0,
 	SOCK_ERROR	= 1 << 1,
@@ -21,6 +23,9 @@ struct IB_SOCK {
 
 	unsigned long		is_flags;
 
+	/* pre-accepted sockets */
+	struct list_head	is_child;
+
 	/* event mask */
 	unsigned long		is_events;
 	wait_queue_head_t	is_events_wait;
diff --git a/ib-sock.c b/ib-sock.c
index fa47955..ae6a5e7 100644
--- a/ib-sock.c
+++ b/ib-sock.c
@@ -1,6 +1,9 @@
 #include "ib-sock.h"
 #include "ib-sock-int.h"
 
+struct IB_SOCK *__ib_socket_create(struct rdma_cm_id *cm_id);
+
+
 static int
 cm_client_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 {
@@ -68,6 +71,57 @@ cm_client_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 	return ret;
 }
 
+static int
+cm_server_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
+{
+	int ret = 0;
+
+	switch (event->event) {
+	case RDMA_CM_EVENT_CONNECT_REQUEST: {
+		/* incomming request - lets allocate a resources for a new connect */
+		const struct ib_hello *hello = event->param.conn.private_data;
+		struct ib_hello hello_ack;
+		struct rdma_conn_param	conn_param;
+		struct IB_SOCK *sock;
+
+		if (hello->magic != IB_HELLO_MAGIC) {
+			printk("Incomming error: len %u magic %x\n",
+				event->param.conn.private_data_len,
+				hello->magic);
+			ret = -EPROTO;
+			break;
+		}
+
+		sock = __ib_socket_create(cmid);
+		if (ret != 0) {
+			printk("error accept \n");
+			ret = -ENOMEM;
+			break;
+		}
+
+		memset(&hello_ack, 0, sizeof hello_ack);
+		hello_ack.magic = IB_HELLO_MAGIC;
+
+		memset(&conn_param, 0, sizeof conn_param);
+		conn_param.private_data_len = sizeof hello_ack;
+		conn_param.private_data = &hello_ack;
+		conn_param.responder_resources = 0 /* no atomic */;
+		conn_param.initiator_depth = 0;
+		conn_param.retry_count = 10;
+
+		ret = rdma_accept(sock->is_id, &conn_param);
+		break;
+	}
+	default:
+		ret = -EINVAL;
+		break;
+	}
+
+	printk("server CM event ret %d\n", ret);
+
+	return ret;
+}
+
 
 static int cm_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 {
@@ -88,6 +142,12 @@ static int cm_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 		break;
 	/* server related events */
 	case RDMA_CM_EVENT_CONNECT_REQUEST:
+		ret = cm_server_handler(cmid, event);
+		/* if we have any errors (including protocol violation 
+		 * during connect handshake, we need a destroy new allocated
+		 * cm_id  */
+		if (ret < 0)
+			return ret;
 		break;
 	/* some common errors */
 	case RDMA_CM_EVENT_ADDR_ERROR:
@@ -98,6 +158,8 @@ static int cm_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 	case RDMA_CM_EVENT_CONNECT_ERROR:
 	case RDMA_CM_EVENT_REJECTED:
 		/* to decode a reject event, see srp_cm_rej_handler */
+		/* reject event hit in two cases - none bind ports, or disconnected on 
+		 * other side */
 		ret = -ECONNREFUSED;
 		break;
 	/* some hard errors to abort connection */
@@ -121,7 +183,7 @@ static int cm_handler(struct rdma_cm_id *cmid, struct rdma_cm_event *event)
 	return 0;
 }
 
-struct IB_SOCK *ib_socket_create()
+struct IB_SOCK *__ib_socket_create(struct rdma_cm_id *cm_id)
 {
 	struct IB_SOCK *sock;
 
@@ -129,23 +191,36 @@ struct IB_SOCK *ib_socket_create()
 	if (sock == NULL)
 		return NULL;
 
-	sock->is_id = rdma_create_id(cm_handler, sock,
-					     RDMA_PS_TCP, IB_QPT_RC);
-	if (IS_ERR(sock->is_id)) {
-		printk("error create cm_id %ld\n", PTR_ERR(sock->is_id));
-		sock->is_id = NULL;
-		goto out_free;
-	}
+	sock->is_id = cm_id;
+	cm_id->context = sock;
 
 	sock->is_flags = 0;
+
+	INIT_LIST_HEAD(&sock->is_child);
+
 	sock->is_events = 0;
 	init_waitqueue_head(&sock->is_events_wait);
 	
 	printk("IB socket create %p\n", sock);
 	return sock;
-out_free:
-	ib_socket_destroy(sock);
-	return NULL;
+}
+
+struct IB_SOCK *ib_socket_create()
+{
+	struct rdma_cm_id *cm_id;
+	struct IB_SOCK *ret;
+	
+	cm_id = rdma_create_id(cm_handler, NULL, RDMA_PS_TCP, IB_QPT_RC);
+	if (IS_ERR(cm_id)) {
+		printk("error create cm_id %ld\n", PTR_ERR(cm_id));
+		return NULL;
+	}
+
+	ret = __ib_socket_create(cm_id);
+	if (ret == NULL)
+		rdma_destroy_id(cm_id);
+
+	return ret;
 }
 
 void ib_socket_destroy(struct IB_SOCK *sock)
@@ -201,7 +276,7 @@ void ib_socket_disconnect(struct IB_SOCK *sock)
 		printk("Failed to disconnect, conn: 0x%p err %d\n",
 			 sock,err);
 }
-
+/*****************************************************************************************/
 static unsigned long __take_event(struct IB_SOCK *sock, unsigned long *e)
 {
 	unsigned long events;
@@ -224,3 +299,43 @@ unsigned long ib_socket_poll(struct IB_SOCK *sock)
 
 	return mask;
 }
+
+/*****************************************************************************************/
+int ib_socket_bind(struct IB_SOCK *sock, uint32_t addr, unsigned port)
+{
+	struct sockaddr_in  sin;
+	int ret;
+
+	sin.sin_family = AF_INET,
+	sin.sin_addr.s_addr = (__force u32)htonl(addr);
+	sin.sin_port = (__force u16)htons(port);
+
+	ret = rdma_bind_addr(sock->is_id, (struct sockaddr *)&sin);
+	if (ret) {
+		printk(KERN_ERR "RDMA: failed to setup listener, "
+		       "rdma_bind_addr() returned %d\n", ret);
+		goto out;
+	}
+
+	ret = rdma_listen(sock->is_id, IB_LISTEN_QUEUE);
+	if (ret) {
+		printk(KERN_ERR "RDMA: failed to setup listener, "
+		       "rdma_listen() returned %d\n", ret);
+		goto out;
+	}
+	/* HELLO will done via CM (mad) packets */
+out:
+	return ret;
+
+}
+
+struct IB_SOCK *ib_socket_accept(struct IB_SOCK *parent)
+{
+	struct IB_SOCK *sock;
+
+	sock = list_first_entry_or_null(&parent->is_child, struct IB_SOCK, is_child);
+	if (sock) {
+		list_del_init(&sock->is_child);
+	}
+	return sock;
+}
diff --git a/ib-sock.h b/ib-sock.h
index 533e991..0a2f9a9 100644
--- a/ib-sock.h
+++ b/ib-sock.h
@@ -25,4 +25,8 @@ void ib_socket_disconnect(struct IB_SOCK *sock);
 /* sleep to wait poll event from socket */
 unsigned long ib_socket_poll(struct IB_SOCK *sock);
 
+int ib_socket_bind(struct IB_SOCK *sock, uint32_t addr, unsigned port);
+struct IB_SOCK *ib_socket_accept(struct IB_SOCK *parent);
+
+
 #endif
\ No newline at end of file
diff --git a/srv.c b/srv.c
index 801b561..76fb030 100644
--- a/srv.c
+++ b/srv.c
@@ -1,14 +1,26 @@
 #include "ib-sock.h"
 
+
+
 static int __init
 srv_init(void)
 {
 	struct IB_SOCK *sock;
+	unsigned long event;
+	int ret;
 
 	sock = ib_socket_create();
 	if (sock == NULL)
 		return -ENOMEM;
 
+	ret = ib_socket_bind(sock, INADDR_ANY, 1998);
+	if (ret < 0)
+		goto out;
+
+	event = ib_socket_poll(sock);
+	/* wait a POLLIN to say new connection ready to */
+
+out:
 	ib_socket_destroy(sock);
 	return 0;
 }
